<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8" />
    <title>Breakout Game - Advanced Edition</title>
    <style>
        * {
            padding: 0;
            margin: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            color: #fff;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 20px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            display: block;
            border-radius: 8px;
        }

        #uiOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            transition: opacity 0.5s ease;
            pointer-events: all;
        }

        .screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 3.5rem;
            margin-bottom: 10px;
            color: #e94560;
            text-shadow: 0 2px 10px rgba(233, 69, 96, 0.5);
            letter-spacing: 2px;
        }

        h2 {
            font-size: 2rem;
            margin-bottom: 30px;
            color: #0fccce;
        }

        .btn {
            background: linear-gradient(to right, #e94560, #ff6b95);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
            pointer-events: all;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(233, 69, 96, 0.6);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .stats {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .stats div {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }

        .instructions {
            max-width: 80%;
            text-align: center;
            margin: 20px 0;
            line-height: 1.6;
            color: #ccc;
        }

        .game-over-message {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .final-score {
            font-size: 1.8rem;
            margin-bottom: 30px;
            color: #ffd166;
        }

        .brick-row {
            display: flex;
            justify-content: center;
            margin: 5px 0;
        }

        .brick {
            width: 50px;
            height: 20px;
            margin: 0 3px;
            border-radius: 3px;
        }

        .brick-1 {
            background: linear-gradient(to bottom, #ff9a9e, #fad0c4);
        }

        .brick-2 {
            background: linear-gradient(to bottom, #a1c4fd, #c2e9fb);
        }

        .brick-3 {
            background: linear-gradient(to bottom, #ffecd2, #fcb69f);
        }

        .leaderboard {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            width: 80%;
            max-width: 400px;
        }

        .leaderboard h3 {
            text-align: center;
            margin-bottom: 15px;
            color: #0fccce;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .power-up-indicator {
            position: absolute;
            bottom: 30px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: none;
        }

        #laserIndicator {
            color: #ff6b6b;
        }

        #multiBallIndicator {
            color: #4ecdc4;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <div id="gameCanvas"></div>

        <div id="uiOverlay">
            <div id="startScreen" class="screen">
                <h1>BREAKOUT</h1>
                <h2>Advanced Edition</h2>

                <div class="instructions">
                    <p>Use your mouse to move the paddle and bounce the ball.</p>
                    <p>Break all the bricks to win! Don't let the ball fall.</p>
                    <p><strong>NEW FEATURES:</strong></p>
                    <p>• Multi-ball power-up - Creates additional balls</p>
                    <p>• Laser paddle - Press SPACE to shoot lasers</p>
                    <p>• Moving bricks - Some bricks move horizontally</p>
                    <p>• Online leaderboard - Compete for high scores</p>
                </div>

                <div class="leaderboard">
                    <h3>LEADERBOARD</h3>
                    <div id="leaderboardList"></div>
                </div>

                <button id="startButton" class="btn">START GAME</button>
            </div>

            <div id="gameOverScreen" class="screen hidden">
                <h1 id="gameOverTitle">GAME OVER</h1>
                <div id="gameOverMessage" class="game-over-message">You ran out of lives!</div>
                <div id="finalScore" class="final-score">Score: 0</div>

                <div class="leaderboard">
                    <h3>LEADERBOARD</h3>
                    <div id="gameOverLeaderboard"></div>
                </div>

                <button id="restartButton" class="btn">PLAY AGAIN</button>
            </div>

            <div class="stats">
                <div id="scoreDisplay">SCORE: <span>0</span></div>
                <div id="livesDisplay">LIVES: <span>3</span></div>
            </div>

            <div id="laserIndicator" class="power-up-indicator">LASER READY (SPACE)</div>
            <div id="multiBallIndicator" class="power-up-indicator">MULTI-BALL ACTIVE</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.90.0/phaser.js"></script>
    <script>
        // Fixed online leaderboard - only shows highest score per player
        class Leaderboard {
            constructor() {
                this.scores = JSON.parse(localStorage.getItem('breakoutLeaderboard')) || [];
                this.ensureUniquePlayers();
            }

            ensureUniquePlayers() {
                // Keep only the highest score for each player
                const playerScores = {};

                this.scores.forEach(score => {
                    if (!playerScores[score.name] || score.score > playerScores[score.name].score) {
                        playerScores[score.name] = score;
                    }
                });

                this.scores = Object.values(playerScores);
                this.scores.sort((a, b) => b.score - a.score);
                this.scores = this.scores.slice(0, 10); // Keep top 10
                localStorage.setItem('breakoutLeaderboard', JSON.stringify(this.scores));
            }

            addScore(name, score) {
                // Check if player already exists
                const existingIndex = this.scores.findIndex(s => s.name === name);

                if (existingIndex !== -1) {
                    // Update score if it's higher
                    if (score > this.scores[existingIndex].score) {
                        this.scores[existingIndex].score = score;
                        this.scores[existingIndex].date = new Date().toLocaleDateString();
                    }
                } else {
                    // Add new score
                    this.scores.push({ name, score, date: new Date().toLocaleDateString() });
                }

                // Sort and keep top 10
                this.scores.sort((a, b) => b.score - a.score);
                this.scores = this.scores.slice(0, 10);
                localStorage.setItem('breakoutLeaderboard', JSON.stringify(this.scores));
            }

            getScores() {
                return this.scores;
            }

            render(containerId) {
                const container = document.getElementById(containerId);
                container.innerHTML = '';

                if (this.scores.length === 0) {
                    container.innerHTML = '<div class="leaderboard-item">No scores yet</div>';
                    return;
                }

                this.scores.forEach((score, index) => {
                    const item = document.createElement('div');
                    item.className = 'leaderboard-item';
                    item.innerHTML = `
                        <span>${index + 1}. ${score.name}</span>
                        <span>${score.score}</span>
                    `;
                    container.appendChild(item);
                });
            }
        }

        class BreakoutGame extends Phaser.Scene {
            constructor() {
                super({ key: 'BreakoutGame' });

                this.ball = null;
                this.paddle = null;
                this.bricks = null;
                this.score = 0;
                this.lives = 3;
                this.playing = false;
                this.powerUps = null;
                this.ballSpeed = 200;
                this.balls = []; // Array to track all balls
                this.lasers = null;
                this.laserActive = false;
                this.laserCooldown = false;
                this.multiBallActive = false;
                this.movingBricks = [];
                this.leaderboard = new Leaderboard();
                this.playerName = "Player";

                // Store collider references
                this.ballPaddleCollider = null;
                this.ballBricksCollider = null;
                this.paddlePowerUpCollider = null;
                this.laserBricksCollider = null;
            }

            preload() {
                // Create simple graphics programmatically instead of loading images
                this.createBallTexture();
                this.createPaddleTexture();
                this.createBrickTextures();
                this.createPowerUpTextures();
                this.createLaserTexture();
            }

            createBallTexture() {
                // Create a ball texture with gradient
                const graphics = this.add.graphics();
                graphics.fillStyle(0xffffff);
                graphics.fillCircle(10, 10, 10);
                graphics.generateTexture('ball', 20, 20);
                graphics.destroy();
            }

            createPaddleTexture() {
                // Create a paddle texture with gradient
                const graphics = this.add.graphics();
                graphics.fillStyle(0x4cc9f0);
                graphics.fillRoundedRect(0, 0, 75, 15, 7);
                graphics.generateTexture('paddle', 75, 15);
                graphics.destroy();
            }

            createBrickTextures() {
                // Create multiple brick textures with different colors
                const colors = [0xff6b6b, 0x4ecdc4, 0xffd166];

                colors.forEach((color, index) => {
                    const graphics = this.add.graphics();
                    graphics.fillStyle(color);
                    graphics.fillRoundedRect(0, 0, 50, 20, 3);
                    graphics.generateTexture(`brick${index}`, 50, 20);
                    graphics.destroy();
                });
            }

            createPowerUpTextures() {
                // Create power-up textures
                const graphics = this.add.graphics();

                // Multi-ball power-up (blue)
                graphics.fillStyle(0x4ecdc4);
                graphics.fillCircle(7, 7, 7);
                graphics.generateTexture('multiBallPowerUp', 14, 14);

                // Laser power-up (red)
                graphics.fillStyle(0xff6b6b);
                graphics.fillCircle(7, 7, 7);
                graphics.generateTexture('laserPowerUp', 14, 14);

                graphics.destroy();
            }

            createLaserTexture() {
                const graphics = this.add.graphics();
                graphics.fillStyle(0xff6b6b);
                graphics.fillRect(0, 0, 3, 15);
                graphics.generateTexture('laser', 3, 15);
                graphics.destroy();
            }

            create() {
                // Set up physics
                this.physics.world.setBoundsCollision(true, true, true, false);

                // Create game objects
                this.createBall();
                this.createPaddle();
                this.initBricks();
                this.initPowerUps();
                this.initLasers();

                // Set up collisions
                this.setupCollisions();

                // Set up input
                this.input.on('pointermove', (pointer) => {
                    if (this.playing) {
                        this.paddle.x = Phaser.Math.Clamp(pointer.x, this.paddle.width / 2, this.game.config.width - this.paddle.width / 2);
                    }
                });

                // Laser input
                this.input.keyboard.on('keydown-SPACE', () => {
                    if (this.playing && this.laserActive && !this.laserCooldown) {
                        this.shootLaser();
                    }
                });

                // UI events
                document.getElementById('startButton').addEventListener('click', () => {
                    this.startGame();
                });

                document.getElementById('restartButton').addEventListener('click', () => {
                    if (!this.playing) {
                        this.restartGame();
                    }
                });

                // Render leaderboard on start screen
                this.leaderboard.render('leaderboardList');

                // Ask for player name
                this.playerName = prompt("Enter your name for the leaderboard:", "Player") || "Player";
            }

            setupCollisions() {
                // Remove existing colliders if they exist
                if (this.ballPaddleCollider) {
                    this.ballPaddleCollider.destroy();
                }
                if (this.ballBricksCollider) {
                    this.ballBricksCollider.destroy();
                }
                if (this.paddlePowerUpCollider) {
                    this.paddlePowerUpCollider.destroy();
                }
                if (this.laserBricksCollider) {
                    this.laserBricksCollider.destroy();
                }

                // Set up new colliders
                this.ballPaddleCollider = this.physics.add.collider(this.balls, this.paddle, this.hitPaddle, null, this);
                this.ballBricksCollider = this.physics.add.collider(this.balls, this.bricks, this.hitBrick, null, this);
                this.paddlePowerUpCollider = this.physics.add.overlap(this.paddle, this.powerUps, this.collectPowerUp, null, this);
                this.laserBricksCollider = this.physics.add.overlap(this.lasers, this.bricks, this.hitBrickWithLaser, null, this);
            }

            update() {
                // Check if any ball is out of bounds
                this.balls.forEach(ball => {
                    if (ball.y > this.game.config.height) {
                        this.removeBall(ball);
                    }
                });

                // Check if all balls are lost
                if (this.balls.length === 0 && this.playing) {
                    this.loseLife();
                }

                // Move moving bricks
                this.updateMovingBricks();

                // Check win condition
                if (this.bricks.countActive() === 0 && this.playing) {
                    this.winGame();
                }

                // Update UI
                document.getElementById('scoreDisplay').querySelector('span').textContent = this.score;
                document.getElementById('livesDisplay').querySelector('span').textContent = this.lives;
            }

            createBall() {
                const ball = this.physics.add.sprite(
                    this.game.config.width / 2,
                    this.game.config.height - 50,
                    'ball'
                );
                ball.setBounce(1);
                ball.setCollideWorldBounds(true);
                ball.body.onWorldBounds = true;

                // Add a subtle glow effect
                ball.setBlendMode(Phaser.BlendModes.ADD);

                this.balls.push(ball);
                return ball;
            }

            createPaddle() {
                this.paddle = this.physics.add.sprite(
                    this.game.config.width / 2,
                    this.game.config.height - 20,
                    'paddle'
                );
                this.paddle.setImmovable(true);
            }

            initBricks() {
                this.bricks = this.physics.add.staticGroup();
                this.movingBricks = [];

                const brickInfo = {
                    width: 50,
                    height: 20,
                    count: {
                        row: 7,
                        col: 5
                    },
                    offset: {
                        top: 60,
                        left: 60
                    },
                    padding: 10
                };

                for (let c = 0; c < brickInfo.count.col; c++) {
                    for (let r = 0; r < brickInfo.count.row; r++) {
                        const brickX = r * (brickInfo.width + brickInfo.padding) + brickInfo.offset.left;
                        const brickY = c * (brickInfo.height + brickInfo.padding) + brickInfo.offset.top;

                        // Use different brick textures for variety
                        const brickType = (r + c) % 3;
                        const brick = this.bricks.create(brickX, brickY, `brick${brickType}`);
                        brick.setOrigin(0);
                        brick.setData('type', brickType);

                        // Make some bricks moving (top row and every 3rd brick in other rows)
                        if (c === 0 || (c > 0 && r % 3 === 0)) {
                            brick.setData('moving', true);
                            brick.setData('direction', 1);
                            brick.setData('speed', Phaser.Math.Between(50, 100));
                            this.movingBricks.push(brick);
                            brick.setTint(0xaaaaaa); // Slightly tint moving bricks
                        }
                    }
                }
            }

            initPowerUps() {
                this.powerUps = this.physics.add.group();
            }

            initLasers() {
                this.lasers = this.physics.add.group({
                    defaultKey: 'laser',
                    maxSize: 10
                });
            }

            startGame() {
                document.getElementById('startScreen').classList.add('hidden');
                this.playing = true;

                // Launch the ball
                this.balls[0].setVelocity(Phaser.Math.Between(-this.ballSpeed, this.ballSpeed), -this.ballSpeed);
            }

            hitPaddle(ball, paddle) {
                // Add some randomness to the bounce
                const diff = ball.x - paddle.x;
                ball.setVelocityX(10 * diff);

                // Add a visual effect
                this.tweens.add({
                    targets: paddle,
                    scaleX: 1.2,
                    scaleY: 1.2,
                    duration: 100,
                    yoyo: true,
                    ease: 'Power2'
                });
            }

            hitBrick(ball, brick) {
                brick.disableBody(true, true);

                // Remove from moving bricks if it was moving
                const movingIndex = this.movingBricks.indexOf(brick);
                if (movingIndex !== -1) {
                    this.movingBricks.splice(movingIndex, 1);
                }

                // Add score based on brick type
                const brickType = brick.getData('type');
                this.score += (brickType + 1) * 10;

                // Visual effect
                this.cameras.main.shake(50, 0.005);

                // Chance to spawn power-up
                if (Phaser.Math.Between(1, 10) <= 2) {
                    this.spawnPowerUp(brick.x, brick.y);
                }

                // Speed up the ball slightly every few bricks
                if (this.bricks.countActive() % 5 === 0) {
                    this.ballSpeed += 10;
                    this.balls.forEach(ball => {
                        const velocity = ball.body.velocity.normalize();
                        ball.setVelocity(velocity.x * this.ballSpeed, velocity.y * this.ballSpeed);
                    });
                }
            }

            hitBrickWithLaser(laser, brick) {
                brick.disableBody(true, true);
                laser.destroy();

                // Remove from moving bricks if it was moving
                const movingIndex = this.movingBricks.indexOf(brick);
                if (movingIndex !== -1) {
                    this.movingBricks.splice(movingIndex, 1);
                }

                // Add score based on brick type
                const brickType = brick.getData('type');
                this.score += (brickType + 1) * 10;

                // Visual effect
                this.cameras.main.shake(30, 0.003);
            }

            spawnPowerUp(x, y) {
                const powerUpType = Phaser.Math.Between(0, 1); // 0 = multi-ball, 1 = laser
                const texture = powerUpType === 0 ? 'multiBallPowerUp' : 'laserPowerUp';

                const powerUp = this.powerUps.create(x, y, texture);
                powerUp.setVelocity(0, 100);
                powerUp.setData('type', powerUpType);
            }

            collectPowerUp(paddle, powerUp) {
                const type = powerUp.getData('type');

                switch (type) {
                    case 0: // Multi-ball
                        this.activateMultiBall();
                        break;

                    case 1: // Laser
                        this.activateLaser();
                        break;
                }

                powerUp.destroy();

                // Show power-up text
                const powerUpText = this.add.text(paddle.x, paddle.y - 20,
                    type === 0 ? 'MULTI-BALL!' : 'LASER!',
                    {
                        fontSize: '16px',
                        fill: type === 0 ? '#4ecdc4' : '#ff6b6b'
                    }
                );
                powerUpText.setOrigin(0.5);

                this.tweens.add({
                    targets: powerUpText,
                    y: powerUpText.y - 50,
                    alpha: 0,
                    duration: 1000,
                    onComplete: () => powerUpText.destroy()
                });
            }

            activateMultiBall() {
                this.multiBallActive = true;
                document.getElementById('multiBallIndicator').style.display = 'block';

                // Create two additional balls
                for (let i = 0; i < 2; i++) {
                    const newBall = this.createBall();
                    newBall.setPosition(this.paddle.x, this.paddle.y - 20);

                    // Set random velocity
                    const angle = Phaser.Math.Between(-30, 30) * (Math.PI / 180);
                    const speed = this.ballSpeed;
                    newBall.setVelocity(
                        Math.sin(angle) * speed,
                        -Math.cos(angle) * speed
                    );
                }

                // Deactivate after 10 seconds
                this.time.delayedCall(10000, () => {
                    this.multiBallActive = false;
                    document.getElementById('multiBallIndicator').style.display = 'none';
                });
            }

            activateLaser() {
                this.laserActive = true;
                document.getElementById('laserIndicator').style.display = 'block';

                // Deactivate after 15 seconds
                this.time.delayedCall(15000, () => {
                    this.laserActive = false;
                    document.getElementById('laserIndicator').style.display = 'none';
                });
            }

            shootLaser() {
                if (this.laserCooldown) return;

                // Create laser from center of paddle
                const laser = this.lasers.get(this.paddle.x, this.paddle.y - 10, 'laser');
                if (laser) {
                    laser.setActive(true);
                    laser.setVisible(true);
                    laser.body.velocity.y = -400;

                    // Set cooldown
                    this.laserCooldown = true;
                    this.time.delayedCall(300, () => {
                        this.laserCooldown = false;
                    });

                    // Auto-destroy laser after 2 seconds
                    this.time.delayedCall(2000, () => {
                        if (laser.active) {
                            laser.destroy();
                        }
                    });
                }
            }

            updateMovingBricks() {
                this.movingBricks.forEach(brick => {
                    if (!brick.active) return;

                    const direction = brick.getData('direction');
                    const speed = brick.getData('speed');

                    // Move brick
                    brick.x += speed * direction * 0.016; // 0.016 approximates delta time

                    // Check bounds and reverse direction if needed
                    if (brick.x <= 0 || brick.x >= this.game.config.width - brick.width) {
                        brick.setData('direction', direction * -1);
                    }

                    // Update physics body position
                    brick.body.updateFromGameObject();
                });
            }

            removeBall(ball) {
                const index = this.balls.indexOf(ball);
                if (index !== -1) {
                    ball.destroy();
                    this.balls.splice(index, 1);
                }
            }

            loseLife() {
                this.lives--;

                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    this.resetBall();
                }
            }

            resetBall() {
                // Create a new ball if none exist
                if (this.balls.length === 0) {
                    this.createBall();
                }

                // Reset the first ball
                this.balls[0].setPosition(this.game.config.width / 2, this.game.config.height - 50);
                this.balls[0].setVelocity(0, 0);

                // Wait a moment before launching the ball again
                this.time.delayedCall(1000, () => {
                    if (this.playing) {
                        this.balls[0].setVelocity(Phaser.Math.Between(-this.ballSpeed, this.ballSpeed), -this.ballSpeed);
                    }
                });
            }

            gameOver() {
                this.playing = false;

                // Add score to leaderboard
                this.leaderboard.addScore(this.playerName, this.score);

                document.getElementById('gameOverTitle').textContent = 'GAME OVER';
                document.getElementById('gameOverMessage').textContent = 'You ran out of lives!';
                document.getElementById('finalScore').textContent = `FINAL SCORE: ${this.score}`;
                this.leaderboard.render('gameOverLeaderboard');
                document.getElementById('gameOverScreen').classList.remove('hidden');
            }

            winGame() {
                this.playing = false;

                // Add score to leaderboard
                this.leaderboard.addScore(this.playerName, this.score);

                document.getElementById('gameOverTitle').textContent = 'VICTORY!';
                document.getElementById('gameOverMessage').textContent = 'You broke all the bricks!';
                document.getElementById('finalScore').textContent = `FINAL SCORE: ${this.score}`;
                this.leaderboard.render('gameOverLeaderboard');
                document.getElementById('gameOverScreen').classList.remove('hidden');

                // Confetti effect
                for (let i = 0; i < 50; i++) {
                    const confetti = this.add.rectangle(
                        Phaser.Math.Between(0, this.game.config.width),
                        Phaser.Math.Between(-100, 0),
                        10, 10,
                        Phaser.Math.Between(0, 0xffffff)
                    );

                    this.tweens.add({
                        targets: confetti,
                        y: this.game.config.height + 100,
                        rotation: Phaser.Math.Between(0, 6),
                        duration: Phaser.Math.Between(2000, 4000),
                        ease: 'Power2'
                    });
                }
            }

            restartGame() {
                // Hide game over screen
                document.getElementById('gameOverScreen').classList.add('hidden');

                // Reset game state
                this.score = 0;
                this.lives = 3;
                this.ballSpeed = 200;
                this.playing = false;
                this.laserActive = false;
                this.multiBallActive = false;
                this.laserCooldown = false;

                // Hide power-up indicators
                document.getElementById('laserIndicator').style.display = 'none';
                document.getElementById('multiBallIndicator').style.display = 'none';

                // Clear all game objects
                this.balls.forEach(ball => ball.destroy());
                this.balls = [];
                this.powerUps.clear(true, true);
                this.lasers.clear(true, true);
                this.bricks.clear(true, true);
                this.movingBricks = [];

                // Reset paddle position
                this.paddle.setPosition(this.game.config.width / 2, this.game.config.height - 20);

                // Recreate game objects
                this.createBall();
                this.initBricks();
                this.initPowerUps();
                this.initLasers();

                // Re-setup collisions with new objects
                this.setupCollisions();

                // Update UI
                document.getElementById('scoreDisplay').querySelector('span').textContent = this.score;
                document.getElementById('livesDisplay').querySelector('span').textContent = this.lives;

                // Show start screen
                document.getElementById('startScreen').classList.remove('hidden');
            }
        }

        // Game configuration
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'gameCanvas',
            backgroundColor: '#1a1a2e',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: BreakoutGame
        };

        // Create the game
        const game = new Phaser.Game(config);
    </script>
</body>

</html>